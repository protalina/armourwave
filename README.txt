kyber_prep.cpp
The purpose of the provided code (kyber_prep.cpp) is to facilitate the reading of data from multiple text files, processing this data to obtain audio samples, decrypting the samples, and finally playing them back as audio through the computer's audio device. It achieves this through a set of functions and utilities designed for audio playback, data processing, and encryption. For audio playback, the code initializes audio playback by configuring the WAVEFORMATEX structure, setting the sample rate to 20,000 samples per second, defining a buffer size of 100,000 samples, and specifying the audio format as 16-bit PCM with stereo output. This configuration ensures that the audio is played back at the desired quality and format. To handle encryption, the code utilizes the Advanced Encryption Standard (AES) for encryption and decryption tasks. The AES implementation operates in ECB (Electronic Codebook) mode with a key length of 256 bits (32 bytes). This encryption scheme ensures secure communication and data privacy during the decryption process. Multithreading is employed to separate the audio playback process from the main execution flow. The PlayAudioThread function is responsible for playing audio from a buffer in a separate thread, allowing the main program to continue its execution while audio playback occurs concurrently. This approach enhances the efficiency and responsiveness of the application. Data processing involves reading data from text files named dataX.txt, where X is an incrementing counter. The content of each file is tokenized based on specific markers (START, MIDDLE, END, OVER). Encrypted data within the files is decrypted using AES with the shared key obtained from the decrypted data. The decrypted data is then converted to audio samples and played back through the audio device. Error handling mechanisms are integrated into the code to address potential issues such as file existence and audio device initialization errors. Error messages are displayed to std::cerr for debugging purposes, enabling easier identification and resolution of any encountered issues.The program operates in a continuous loop, incrementing the file counter to process subsequent text files. This loop ensures that the program can handle multiple sets of data files without manual intervention, providing a seamless and automated processing pipeline for audio playback and decryption tasks. File Processing and Parsing: The program efficiently handles file operations, parsing, and data extraction. Within the main function, it utilizes std::ifstream::open and std::getline for file access and traversal. Tokenization of file content is achieved through std::string::find and std::string::substr, enabling precise segmentation of relevant data segments within the files. These operations are essential for extracting encrypted data, facilitating subsequent decryption and audio playback. Decryption: The program decrypts encrypted data retrieved from files using functionalities from the Kyber cryptographic library, such as kyber512_kem::decapsulate, to derive shared keys from ciphertext. Additionally, AES encryption and decryption operations are performed using functions from an AES implementation, like AES::DecryptECB, enabling the conversion of encrypted data into its original plaintext form. These decryption processes are vital for rendering encrypted audio data into a playable format. Audio Playback: The program initializes audio playback through functions like InitAudioPlayback, setting up parameters for audio playback via the Windows Multimedia API. The waveOutWrite function initiates audio playback, while multithreading techniques, implemented via std::thread, enable concurrent execution of audio playback operations alongside other program tasks. These functionalities are crucial for rendering decrypted data as audible output, providing real-time feedback on the decryption process. Continuous Loop: An integral part of the program's design is its perpetual execution loop within the main function. This loop ensures continuous operation, allowing the program to iterate indefinitely, process files sequentially, and orchestrate decryption and audio playback without interruption. Managed by the main function, this loop mechanism facilitates ongoing processing of files and uninterrupted playback of decrypted audio data, enhancing the program's efficiency. 

This is also similar handling on the end of the raspberry pi however there is additional libraries used to handle parsing the data through to another end (web sockets).

index.js
This code behind the backend of receiving different components/modules and displays them with the frontend orchestrates a multi-server setup to facilitate communication between various devices and a web application. It begins by establishing two TCP servers, each serving a distinct purpose. The first server, `espServer`, is dedicated to communicating with an ESP device. When the ESP device connects, data sent from it is collected and stored in a buffer (`espBuffer`). Complete strings are extracted from this buffer, processed, and stored in the `newString` variable. The second server, `mainServer`, handles communication with other clients. Similarly, it accumulates incoming data in a buffer (`mainBuffer`), processes complete strings, and writes them to individual text files with unique filenames. Following this, a WebSocket server (`wss`) is set up using the `ws` library. It listens for client connections, particularly focusing on receiving image data. Upon receiving such data, it invokes the `processImage` function to save the image on the server. Additionally, it handles disconnections and errors gracefully. Lastly, an Express server (`appOne`) serves as the backend for a web application. It serves static files from the 'public' directory and provides an API endpoint (`/data`) to deliver data to the frontend, including the latest string received from the ESP device (`newString`) and the current timestamp. This intricate network of servers and clients demonstrates a comprehensive approach to handling diverse communication needs within a networked environment, utilizing various protocols (TCP, WebSocket, HTTP) to ensure seamless interaction between devices and the web application.